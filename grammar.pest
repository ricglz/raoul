WHITESPACE = _{" " | NEWLINE}

// Tokens
DOT        = {"."}
STR_MARK   = _{"\"" | "'"}
COLON      = {":"}
UNDERSCORE = {"_"}
ASGN       = { "=" }
COMMA      = _{","}
SEMI_COLON = {";"}

MINUS = {"-"}
SUM   = {"+"}
DIV   = {"/"}
TIMES = {"*"}

GT  = {">"}
GTE = {">="}
LT  = {"<"}
LTE = {"<="}
EQ  = {"=="}
NE  = {"!="}

L_BRACKET = {"{"}
R_BRACKET = {"}"}
L_PAREN   = {"("}
R_PAREN   = {")"}
L_SQUARE  = {"["}
R_SQUARE  = {"]"}

AND = {"AND"}
OR  = {"OR"}
NOT = {"NOT"}

BOOL   = {"bool"}
FLOAT  = {"float"}
INT    = {"int"}
STRING = {"string"}
VOID   = {"void"}

FUNC   = {"func"}
MAIN   = {"main"}
IF     = {"if"}
ELSE   = {"else"}
PRINT  = {"print"}
WHILE  = {"while"}
FOR    = {"for"}
TO     = {"to"}
GLOBAL = {"global"}
INPUT  = {"input"}

TRUE = {"true"}
FALSE = {"false"}

READ_CSV_KEY = {"read_csv"}
AVERAGE_KEY = {"average"}
STD_KEY = {"std"}
MODE_KEY = {"mode"}
VARIANCE_KEY = {"variance"}

RETURN_KEY = {"return"}

// Grammar

ART_OP  = {MINUS | SUM}
FACT_OP = {DIV | TIMES}

COMP_OP = { EQ | NE }
REL_OP  = { GT | GTE | LT | LTE }

KEYWORD_TYPE = {
  AND          |
  OR           |
  NOT          |
  BOOL         |
  FLOAT        |
  INT          |
  STRING       |
  VOID         |
  FUNC         |
  MAIN         |
  IF           |
  ELSE         |
  PRINT        |
  WHILE        |
  FOR          |
  TO           |
  GLOBAL       |
  INPUT        |
  TRUE         |
  FALSE        |
  READ_CSV_KEY |
  AVERAGE_KEY  |
  STD_KEY      |
  MODE_KEY     |
  VARIANCE_KEY |
  RETURN_KEY
}
KEYWORD = @{KEYWORD_TYPE ~ !ID_SUFFIX}

ID_SUFFIX = { ASCII_ALPHANUMERIC | UNDERSCORE }
ID = @{ !KEYWORD ~ ASCII_ALPHA ~ ID_SUFFIX* }

BOOL_CTE     = @{TRUE | FALSE}
INT_CTE      = @{ MINUS? ~ ASCII_DIGIT+ }
FLOAT_CTE    = @{ INT_CTE ~ DOT ~ ASCII_DIGIT+ }
STRING_VALUE = {(!PEEK ~ ANY)*}
STRING_CTE   = _{ PUSH(STR_MARK) ~ STRING_VALUE ~ POP }
ATOM_CTE     = _{BOOL_CTE | FLOAT_CTE | INT_CTE | STRING_CTE}
ARR_CTE      = _{L_SQUARE ~ EXPRS? ~ R_SQUARE}
CTE          = { ARR_CTE | ATOM_CTE }
ARR_INDEX    = {L_SQUARE ~ EXPR ~ R_SQUARE}
ARR_VAL      = { ID ~ ARR_INDEX{1,2} }
NON_CTE      = {FUNC_CALL | ARR_VAL | ID}
VAR_VAL      = _{CTE | NON_CTE}

EXPR      = { AND_TERM ~ (OR ~ AND_TERM)* }
AND_TERM  = { COMP_TERM ~ (AND ~ COMP_TERM)* }
COMP_TERM = { REL_TERM ~ (COMP_OP ~ REL_TERM)? }
REL_TERM  = { ART_TERM ~ (REL_OP ~ ART_TERM)? }
ART_TERM  = { FACT_TERM ~ (ART_OP ~ FACT_TERM)* }
FACT_TERM = { OPERAND ~ (FACT_OP ~ OPERAND)* }
OPERAND   = _{ NOT? ~ ( L_PAREN ~ EXPR ~ R_PAREN | VAR_VAL ) }
EXPRS     = { EXPR ~ (COMMA ~ EXPR)* }

ATOMIC_TYPES = { BOOL | FLOAT | INT | STRING }
ARR_TYPES    = {L_SQUARE ~ (ATOMIC_TYPES | ARR_TYPES) ~ R_SQUARE}
VAR_TYPES    = {ARR_TYPES | ATOMIC_TYPES}
TYPES        = { VAR_TYPES | VOID}

READ = {INPUT ~ L_PAREN ~ R_PAREN}

ASSIGNMENT = { GLOBAL? ~ ID ~ ASGN ~ (READ | EXPR) }

BLOCK = { L_BRACKET ~ STAMENT* ~ R_BRACKET }

FUNC_ARG      = {ID ~ COLON ~ VAR_TYPES}
FUNC_ARGS     = { FUNC_ARG ~ (COMMA ~ FUNC_ARG)* }
FUNC_HEADER   = { FUNC ~ ID ~ L_PAREN ~ FUNC_ARGS? ~ R_PAREN ~ COLON ~ TYPES }
FUNCTION      = { FUNC_HEADER ~ BLOCK }
MAIN_FUNCTION = { FUNC ~ MAIN ~ L_PAREN ~ R_PAREN ~ COLON ~ VOID ~ BLOCK }
FUNC_CALL     = { ID ~ L_PAREN ~ EXPRS? ~ R_PAREN }

COND_EXPR  = { L_PAREN ~ EXPR ~ R_PAREN }
IF_BLOCK   = { IF ~ COND_EXPR ~ BLOCK }
ELSE_BLOCK = { ELSE ~ (BLOCK | DECISION) }
DECISION   = { IF_BLOCK ~ ELSE_BLOCK? }

WRITE = {PRINT ~ L_PAREN ~ EXPRS? ~ R_PAREN }

WHILE_LOOP = {WHILE ~ COND_EXPR ~ BLOCK}

FOR_LOOP = {FOR ~ L_PAREN ~ ASSIGNMENT ~ TO ~ EXPR ~ R_PAREN ~ BLOCK}

POSSIBLE_STR         = {STRING_CTE | NON_CTE}
READ_CSV_EXTRA       = {(COMMA ~ ID){2}}
READ_CSV             = {READ_CSV_KEY ~ L_PAREN ~ POSSIBLE_STR ~ READ_CSV_EXTRA? ~ R_PAREN}
OPTIONAL_COLUMN_FUNC = {L_PAREN ~ ID ~ (COMMA ~ POSSIBLE_STR)? ~ R_PAREN}
AVERAGE              = {AVERAGE_KEY ~ OPTIONAL_COLUMN_FUNC}
STD                  = {STD_KEY ~ OPTIONAL_COLUMN_FUNC}
MODE                 = {MODE_KEY ~ OPTIONAL_COLUMN_FUNC}
VARIANCE             = {VARIANCE_KEY ~ OPTIONAL_COLUMN_FUNC}
DATAFRAME_OPS        = {READ_CSV | AVERAGE | STD | MODE | VARIANCE}

RETURN = { RETURN_KEY ~ EXPR }

BLOCK_STATEMENT  = { DECISION | WHILE_LOOP | FOR_LOOP }
INLINE_STATEMENT = { DATAFRAME_OPS | ASSIGNMENT | WRITE | RETURN | FUNC_CALL }
STAMENT          = { INLINE_STATEMENT ~ SEMI_COLON | BLOCK_STATEMENT }

PROGRAM = { SOI ~ FUNCTION* ~ MAIN_FUNCTION ~ EOI }
