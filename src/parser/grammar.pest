WHITESPACE = _{" " | NEWLINE}

// Tokens
DOT        = _{"."}
STR_MARK   = _{"\"" | "'"}
COLON      = _{":"}
UNDERSCORE = _{"_"}
ASGN       = _{ "=" }
COMMA      = _{","}
SEMI_COLON = _{";"}

MINUS = {"-"}
SUM   = {"+"}
DIV   = {"/"}
TIMES = {"*"}

GT  = {">"}
GTE = {">="}
LT  = {"<"}
LTE = {"<="}
EQ  = {"=="}
NE  = {"!="}

L_BRACKET = _{"{"}
R_BRACKET = _{"}"}
L_PAREN   = _{"("}
R_PAREN   = _{")"}
L_SQUARE  = _{"["}
R_SQUARE  = _{"]"}

AND = {"AND"}
OR  = {"OR"}
NOT = {"NOT"}

BOOL   = {"bool"}
FLOAT  = {"float"}
INT    = {"int"}
STRING = {"string"}
void   = {"void"}

FUNC   = _{"func"}
MAIN   = _{"main"}
IF     = _{"if"}
ELSE   = _{"else"}
PRINT  = _{"print"}
WHILE  = _{"while"}
FOR    = _{"for"}
TO     = _{"to"}
GLOBAL = _{"global"}
INPUT  = _{"input"}

TRUE  = _{"true"}
FALSE = _{"false"}

READ_CSV_KEY = _{"read_csv"}
AVERAGE_KEY  = _{"average"}
STD_KEY      = _{"std"}
MODE_KEY     = _{"mode"}
VARIANCE_KEY = _{"variance"}

RETURN_KEY = _{"return"}

// Grammar

ART_OP  = _{MINUS | SUM}
FACT_OP = _{DIV | TIMES}

COMP_OP = _{ EQ | NE }
REL_OP  = _{ GT | GTE | LT | LTE }

KEYWORD_TYPE = _{
  AND          |
  OR           |
  NOT          |
  BOOL         |
  FLOAT        |
  INT          |
  STRING       |
  void         |
  FUNC         |
  MAIN         |
  IF           |
  ELSE         |
  PRINT        |
  WHILE        |
  FOR          |
  TO           |
  GLOBAL       |
  INPUT        |
  TRUE         |
  FALSE        |
  READ_CSV_KEY |
  AVERAGE_KEY  |
  STD_KEY      |
  MODE_KEY     |
  VARIANCE_KEY |
  RETURN_KEY
}
KEYWORD = _{ KEYWORD_TYPE ~ !ID_SUFFIX }

ID_SUFFIX = _{ ASCII_ALPHANUMERIC | UNDERSCORE }
ID = @{ !KEYWORD ~ ASCII_ALPHA ~ ID_SUFFIX* }

BOOL_CTE     = @{ TRUE | FALSE }
INT_CTE      = @{ MINUS? ~ ASCII_DIGIT+ }
FLOAT_CTE    = @{ INT_CTE ~ DOT ~ ASCII_DIGIT+ }
STRING_VALUE = { (!PEEK ~ ANY)* }
STRING_CTE   = _{ PUSH(STR_MARK) ~ STRING_VALUE ~ POP }
ATOM_CTE     = _{ BOOL_CTE | FLOAT_CTE | INT_CTE | STRING_CTE }
ARR_CTE      = { L_SQUARE ~ EXPRS? ~ R_SQUARE }
CTE          = _{ ARR_CTE | ATOM_CTE }
ARR_INDEX    = { L_SQUARE ~ EXPR ~ R_SQUARE }
ARR_VAL      = { ID ~ ARR_INDEX{1,2} }
NON_CTE      = _{ DATAFRAME_OPS | FUNC_CALL | ARR_VAL | ID }
VAR_VAL      = _{ CTE | NON_CTE }

EXPR      = { AND_TERM ~ (OR ~ AND_TERM)* }
AND_TERM  = { COMP_TERM ~ (AND ~ COMP_TERM)* }
COMP_TERM = { REL_TERM ~ (COMP_OP ~ REL_TERM)? }
REL_TERM  = { ART_TERM ~ (REL_OP ~ ART_TERM)? }
ART_TERM  = { FACT_TERM ~ (ART_OP ~ FACT_TERM)* }
FACT_TERM = { OPERAND ~ (FACT_OP ~ OPERAND)* }
OPERAND   = { NOT? ~ (L_PAREN ~ EXPR ~ R_PAREN | VAR_VAL) }
EXPRS     = { EXPR ~ (COMMA ~ EXPR)* }

ATOMIC_TYPES = _{ BOOL | FLOAT | INT | STRING }
ARR_TYPES    = { L_SQUARE ~ (ATOMIC_TYPES | ARR_TYPES) ~ R_SQUARE }
VAR_TYPES    = _{ ARR_TYPES | ATOMIC_TYPES }
TYPES        = _{ VAR_TYPES | void}

READ = { INPUT ~ L_PAREN ~ R_PAREN }

ASSIGNMENT_EXP = _{ READ | EXPR }
ASSIGNMENT     = { GLOBAL? ~ ID ~ ASGN ~ ASSIGNMENT_EXP }

block = { L_BRACKET ~ statement* ~ R_BRACKET }

FUNC_ARG      = { ID ~ COLON ~ VAR_TYPES }
FUNC_ARGS     = { FUNC_ARG ~ (COMMA ~ FUNC_ARG)* }
FUNC_HEADER   = { FUNC ~ ID ~ L_PAREN ~ FUNC_ARGS? ~ R_PAREN ~ COLON ~ TYPES }
function      = { FUNC_HEADER ~ block }
MAIN_FUNCTION = _{ FUNC ~ MAIN ~ L_PAREN ~ R_PAREN ~ COLON ~ void ~ block }
FUNC_CALL     = { ID ~ L_PAREN ~ EXPRS? ~ R_PAREN }

COND_EXPR  = { L_PAREN ~ EXPR ~ R_PAREN }
IF_BLOCK   = { IF ~ COND_EXPR ~ block }
ELSE_BLOCK = { ELSE ~ (block | DECISION) }
DECISION   = { IF_BLOCK ~ ELSE_BLOCK? }

WRITE = {PRINT ~ L_PAREN ~ EXPRS? ~ R_PAREN }

WHILE_LOOP = {WHILE ~ COND_EXPR ~ block}

FOR_LOOP = {FOR ~ L_PAREN ~ ASSIGNMENT ~ TO ~ EXPR ~ R_PAREN ~ block}

POSSIBLE_STR         = {STRING_CTE | NON_CTE}
READ_CSV_EXTRA       = {(COMMA ~ ID){2}}
READ_CSV             = {READ_CSV_KEY ~ L_PAREN ~ POSSIBLE_STR ~ READ_CSV_EXTRA? ~ R_PAREN}
OPTIONAL_COLUMN_FUNC = {L_PAREN ~ ID ~ (COMMA ~ POSSIBLE_STR)? ~ R_PAREN}
AVERAGE              = {AVERAGE_KEY ~ OPTIONAL_COLUMN_FUNC}
STD                  = {STD_KEY ~ OPTIONAL_COLUMN_FUNC}
MODE                 = {MODE_KEY ~ OPTIONAL_COLUMN_FUNC}
VARIANCE             = {VARIANCE_KEY ~ OPTIONAL_COLUMN_FUNC}
DATAFRAME_OPS        = _{READ_CSV | AVERAGE | STD | MODE | VARIANCE}

RETURN = { RETURN_KEY ~ EXPR }

BLOCK_STATEMENT  = _{ DECISION | WHILE_LOOP | FOR_LOOP }
INLINE_STATEMENT = _{ DATAFRAME_OPS | ASSIGNMENT | WRITE | RETURN | FUNC_CALL }
statement        = { INLINE_STATEMENT ~ SEMI_COLON | BLOCK_STATEMENT }

program = { SOI ~ function* ~ MAIN_FUNCTION ~ EOI }
