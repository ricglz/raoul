WHITESPACE = _{" " | NEWLINE}

// Tokens
DOT        = _{"."}
STR_MARK   = _{"\"" | "'"}
COLON      = _{":"}
UNDERSCORE = _{"_"}
ASGN       = _{ "=" }
COMMA      = _{","}
SEMI_COLON = _{";"}

MINUS = {"-"}
SUM   = {"+"}
DIV   = {"/"}
TIMES = {"*"}

GT  = {">"}
GTE = {">="}
LT  = {"<"}
LTE = {"<="}
EQ  = {"=="}
NE  = {"!="}

L_BRACKET = _{"{"}
R_BRACKET = _{"}"}
L_PAREN   = _{"("}
R_PAREN   = _{")"}
L_SQUARE  = _{"["}
R_SQUARE  = _{"]"}

AND = {"AND"}
OR  = {"OR"}
not = {"not"}

BOOL   = {"bool"}
FLOAT  = {"float"}
INT    = {"int"}
STRING = {"string"}
void   = {"void"}

FUNC   = _{"func"}
MAIN   = _{"main"}
IF     = _{"if"}
ELSE   = _{"else"}
PRINT  = _{"print"}
WHILE  = _{"while"}
FOR    = _{"for"}
TO     = _{"to"}
GLOBAL = _{"global"}
INPUT  = _{"input"}

TRUE  = _{"true"}
FALSE = _{"false"}

READ_CSV_KEY = _{"read_csv"}
AVERAGE_KEY  = _{"average"}
STD_KEY      = _{"std"}
MODE_KEY     = _{"mode"}
VARIANCE_KEY = _{"variance"}

RETURN_KEY = _{"return"}

// Grammar

ART_OP  = _{MINUS | SUM}
FACT_OP = _{DIV | TIMES}

COMP_OP = _{ EQ | NE }
REL_OP  = _{ GT | GTE | LT | LTE }

KEYWORD_TYPE = _{
  AND          |
  OR           |
  not          |
  BOOL         |
  FLOAT        |
  INT          |
  STRING       |
  void         |
  FUNC         |
  MAIN         |
  IF           |
  ELSE         |
  PRINT        |
  WHILE        |
  FOR          |
  TO           |
  GLOBAL       |
  INPUT        |
  TRUE         |
  FALSE        |
  READ_CSV_KEY |
  AVERAGE_KEY  |
  STD_KEY      |
  MODE_KEY     |
  VARIANCE_KEY |
  RETURN_KEY
}
KEYWORD = _{ KEYWORD_TYPE ~ !ID_SUFFIX }

ID_SUFFIX = _{ ASCII_ALPHANUMERIC | UNDERSCORE }
id = @{ !KEYWORD ~ ASCII_ALPHA ~ ID_SUFFIX* }

BOOL_CTE     = @{ TRUE | FALSE }
int_cte      = @{ MINUS? ~ ASCII_DIGIT+ }
FLOAT_CTE    = @{ int_cte ~ DOT ~ ASCII_DIGIT+ }
STRING_VALUE = { (!PEEK ~ ANY)* }
STRING_CTE   = _{ PUSH(STR_MARK) ~ STRING_VALUE ~ POP }
ATOM_CTE     = _{ BOOL_CTE | FLOAT_CTE | int_cte | STRING_CTE }
ARR_CTE      = { L_SQUARE ~ exprs? ~ R_SQUARE }
CTE          = _{ ARR_CTE | ATOM_CTE }
ARR_INDEX    = { L_SQUARE ~ expr ~ R_SQUARE }
ARR_VAL      = { id ~ ARR_INDEX{1,2} }
NON_CTE      = _{ DATAFRAME_OPS | FUNC_CALL | ARR_VAL | id }
VAR_VAL      = _{ CTE | NON_CTE }

expr          = { and_term ~ (OR ~ and_term)* }
and_term      = { comp_term ~ (AND ~ comp_term)* }
comp_term     = { rel_term ~ (COMP_OP ~ rel_term)? }
rel_term      = { art_term ~ (REL_OP ~ art_term)? }
art_term      = { fact_term ~ (ART_OP ~ fact_term)* }
fact_term     = { operand ~ (FACT_OP ~ operand)* }
operand       = { not? ~ operand_value }
operand_value = { L_PAREN ~ expr ~ R_PAREN | VAR_VAL }
exprs         = { expr ~ (COMMA ~ expr)* }

ATOMIC_TYPES = _{ BOOL | FLOAT | INT | STRING }
ARR_TYPES    = { L_SQUARE ~ (ATOMIC_TYPES | ARR_TYPES) ~ R_SQUARE }
VAR_TYPES    = _{ ARR_TYPES | ATOMIC_TYPES }
TYPES        = _{ VAR_TYPES | void}

READ = { INPUT ~ L_PAREN ~ R_PAREN }

ASSIGNMENT_EXP = _{ READ | expr }
assignment     = { GLOBAL? ~ id ~ ASGN ~ ASSIGNMENT_EXP }

block = { L_BRACKET ~ statement* ~ R_BRACKET }

FUNC_ARG      = { id ~ COLON ~ VAR_TYPES }
FUNC_ARGS     = { FUNC_ARG ~ (COMMA ~ FUNC_ARG)* }
FUNC_HEADER   = { FUNC ~ id ~ L_PAREN ~ FUNC_ARGS? ~ R_PAREN ~ COLON ~ TYPES }
function      = { FUNC_HEADER ~ block }
MAIN_FUNCTION = _{ FUNC ~ MAIN ~ L_PAREN ~ R_PAREN ~ COLON ~ void ~ block }
FUNC_CALL     = { id ~ L_PAREN ~ exprs? ~ R_PAREN }

COND_EXPR  = { L_PAREN ~ expr ~ R_PAREN }
IF_BLOCK   = { IF ~ COND_EXPR ~ block }
ELSE_BLOCK = { ELSE ~ (block | DECISION) }
DECISION   = { IF_BLOCK ~ ELSE_BLOCK? }

write = {PRINT ~ L_PAREN ~ exprs? ~ R_PAREN }

WHILE_LOOP = {WHILE ~ COND_EXPR ~ block}

FOR_LOOP = {FOR ~ L_PAREN ~ assignment ~ TO ~ expr ~ R_PAREN ~ block}

POSSIBLE_STR         = {STRING_CTE | NON_CTE}
READ_CSV_EXTRA       = {(COMMA ~ id){2}}
READ_CSV             = {READ_CSV_KEY ~ L_PAREN ~ POSSIBLE_STR ~ READ_CSV_EXTRA? ~ R_PAREN}
OPTIONAL_COLUMN_FUNC = {L_PAREN ~ id ~ (COMMA ~ POSSIBLE_STR)? ~ R_PAREN}
AVERAGE              = {AVERAGE_KEY ~ OPTIONAL_COLUMN_FUNC}
STD                  = {STD_KEY ~ OPTIONAL_COLUMN_FUNC}
MODE                 = {MODE_KEY ~ OPTIONAL_COLUMN_FUNC}
VARIANCE             = {VARIANCE_KEY ~ OPTIONAL_COLUMN_FUNC}
DATAFRAME_OPS        = _{READ_CSV | AVERAGE | STD | MODE | VARIANCE}

RETURN = { RETURN_KEY ~ expr }

BLOCK_STATEMENT  = _{ DECISION | WHILE_LOOP | FOR_LOOP }
INLINE_STATEMENT = _{ DATAFRAME_OPS | assignment | write | RETURN | FUNC_CALL }
statement        = { INLINE_STATEMENT ~ SEMI_COLON | BLOCK_STATEMENT }

program = { SOI ~ function* ~ MAIN_FUNCTION ~ EOI }
